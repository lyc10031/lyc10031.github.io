---
layout: article
title: java 动态规划 学习记录
tags: 
- java
- 动态规划
- 算法笔记
key: Java-algorithm-动态规划
aside:
  toc: true
---

# 输出一个数组组合之后的最大数
```java
@Test
    public void test(){
      int[] num = {1,2,3,4,5,27};
        String reduce = Arrays.stream(num).mapToObj(String::valueOf)
                .sorted((s1, s2) -> (s2 + s1).compareTo(s1 + s2))
                .reduce("", (s1, s2) -> (s1 + s2));
        System.out.println(reduce.charAt(0) =='0'?0:reduce);
    }
```

# 查找数组中具有最大和的连续子数组。

## 解释
定义了一个整数数组 xx 存储了一组整数。
maxSum 用于记录当前已经遍历过的子数组的最大和，初始化为整型最小值 Integer.MIN_VALUE。
maxB 和 maxE 用于记录当前最大子数组的起始索引和结束索引。
tsum 用于记录当前正在累积的子数组的和。
使用 for 循环遍历数组 xx：
在每次迭代中，将当前元素加到 tsum 中，表示累积当前子数组的和。
如果 tsum 大于 maxSum，更新 maxSum 和 maxE，以记录找到的更大的子数组和以及结束索引。
如果 tsum 小于等于 0，表示当前累积的子数组和不再对后续的和有正向贡献，因此更新 maxB，以重新开始计算下一个子数组的和。
使用第二个 for 循环将找到的最大子数组的元素加入到 ll 列表中。
最后打印输出 ll 列表，即找到的具有最大和的连续子数组。
这段代码的核心思想是利用动态规划的思想，在遍历数组的过程中不断更新当前的最大子数组和以及起始和结束索引，从而得到整个数组中具有最大和的连续子数组。

```java

     @Test
      public void test(){
          int[] xx = {-1,2,4,-2,0,10,-3,6,-7,5,-10};
          int maxSum = Integer.MIN_VALUE;
          int maxB = 0;
          int maxE = 0;
          int tsum = 0;
          for (int i = 0; i < xx.length; i++) {
              tsum += xx[i];
              if (tsum > maxSum) {
                  maxE = i;
                  maxSum  = tsum;
              }
              if (tsum <= 0) {
                  maxB = i+1;
              }
          }
          List<Integer> ll = new ArrayList<>();
          for (int i = maxB; i <=maxE ; i++) {
              ll.add(xx[i]);
          };
          System.out.println(ll);
      }
```

# 最长回文子数组
* 从中间往两边遍历。
* 使用 boolean[][] 数组记录 i到j 是否是回文数组。
* 因为是从中间往两边遍历，所以：
1. charArray[j] == charArray[i] 判断当前的ij 是否是回文，再判断 2、或者3
2.  i-j <= 2 代表 组成 回文的最小单位
        1个：a 单个字符 也是回文 、2个 aa 两个字符 是回文 、3个 aba 三个字符 是回文
3. mark[j+1][i-1] 代表前一个已经判断过的子数组 是否是回文
判断 i-j+1 > maxL
记录 最长回文的maxb 起始下标、结尾下标、长度 当长度 大于 之前的最大长度时就记录当前的 j 为开头 i 为结尾 maxL 为长度
最后 s.substring(maxb,maxE + 1)   这个方法是左闭右开的 所以需要 是 maxE + 1
```java
  @Test
    public void test(){
        String xx = "abcbadeoeda";

        int maxB = 0;
        int maxE = 0;
        int maxL = 1;
        char[] charArray = xx.toCharArray();
        boolean[][] mark = new boolean[charArray.length][charArray.length];
        for (int i = 1; i < charArray.length; i++) {
            for (int j = 0; j < i; j++) {
                if (charArray[j] == charArray[i] && (i-j<=2 || mark[j+1][i-1])) {
                    mark[j][i] = true;
                    if (i-j+1 > maxL) {
                        maxL = i-j +1;
                        maxB = j;
                        maxE = i;
                    }
                }
            }
        }
        System.out.println(xx.substring(maxB,maxE +1));
    }

```

# 最接近的三数之和
```java
 @Test
    public void testNearestThreeNumbersSum(){
        int[] nums = {1,2,3,4,5,6,7,8,9};
        int target = 17;
        Arrays.sort(nums);
        int x = 0;
        for (int i = 0; i < nums.length; i++) {
            int l = x+1,r = nums.length-1;
            while (l<r) {
                int t = nums[l] + nums[i]+ nums[r];
                if (Math.abs(target - t) < Math.abs(target -x)) {
                    x = t;
                }
                if (t > target) {
                    r--;
                }else {
                    l++;
                }
            }
        }
        System.out.println(x);
    }

```

# 三数之和
  https://leetcode.cn/problems/1fGaJU/description/
    三数之和
    给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a ，b ，c ，使得 a + b + c = 0 ？请找出所有和为 0 且 不重复 的三元组。

    示例 1：

    输入：nums = [-1,0,1,2,-1,-4]
    输出：[[-1,-1,2],[-1,0,1]]
    示例 2：

    输入：nums = []
    输出：[]
    示例 3：

    输入：nums = [0]
    输出：[]
## 解答:
```java
 @Test
    public void test(){
        int[] nums = {-1,0,1,2,-1,-4};
        Arrays.sort(nums);
        List<List<Integer>> lists = new ArrayList<List<Integer>>();
        for (int i = 0; i < nums.length; i++) {
            int l = i + 1,r = nums.length-1;
            while (l<r) {
                int t = nums[i] + nums[l] + nums[r];
                if( t==0) {
                    ArrayList<Integer> integers1 = new ArrayList<>(Arrays.asList(nums[i], nums[l], nums[r]));
                    lists.add(integers1);
                    if (nums[l] == nums[l++] || nums[r]== nums[r--]) {
                        break;
                    }
                    l ++;
                    r --;
                } else if (t < 0) {
                    l++;
                }else {
                    r--;
                }
            }
        }
        System.out.println(lists);
    }


```

<a href="javascript:scroll(0,0)">-- 返回顶部 --</a>


