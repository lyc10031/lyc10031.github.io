---
layout: article
title: go知识点
tags: 
- GO
- 学习记录
key: go-tips
aside:
  toc: true
---
## golang 的堆和栈


```
var p *int    //全局指针变量
func f(){
    var i int
    i = 1
    p = &i    //全局指针变量指向局部变量i
}
```

```
func f(){
    p := new(int) //局部指针变量，使用new申请的空间
    *p = 1
}
```
###  上面程序中，第一个程序虽然i是通过var申请的局部变量，但是由于有外部指针指向访问，我们有路径可找到这个空间（变量能够逃逸出函数），所以局部变量i是申请在堆空间上。而第二个程序中p指针变量虽然是使用new申请的空间，但是由于退出函数就没有路径可寻找到它（变量无法逃出函数），所以局部变量p是申请在栈空间上的。


- golang 1.13 defer新增了一个heap字段用于标识_defer 是在堆上还是在栈上。编译器会根据应用场景去选择使用 deferproc 还是 deferprocStack 方法，他们分别是针对分配在堆上和栈上的使用场景。也就是当 defer func 是顶级函数时，将会分配到栈上。但是若在 defer func 外层出现显式的迭代循环，又或是出现隐式迭代，将会分配到堆上。

- 得益于其延迟对象的堆栈分配规则的改变，措施是由编译器通过对 defer 的 for-loop 迭代深度进行分析，如果 loopdepth 为 1，则设置逃逸分析的结果，将分配到栈上，否则分配到堆上。进而加快了defer的处理速度，官方说明 Go1.13 defer 性能提高 30%。

[Go1.13 defer 的性能是如何提高的？](https://book.eddycjy.com/golang/talk/go1.13-defer.html)


## defer
- defer 是后进先出。panic 需要等defer 结束后才会向上传递。 出现panic会先按照defer的后入先出的顺序执行，最后才会执行panic。
### 例子1：

```
package main

import "fmt"

func calc(index string, a, b int) int {
	ret := a + b
	fmt.Println(index, a, b, ret)
	return ret
}

func main() {
	a := 1
	b := 2
	defer calc("1", a, calc("10", a, b))
	a = 0
	defer calc("2", a, calc("20", a, b))
	b = 1
}
OUTPUT >> 
10 1 2 3
20 0 2 2
2 0 2 2
1 1 3 4

```

- 解释：defer 依据先入后出的规则，外围的calc 将会是先2后1, 在calc内部的calc 会在声明defer的时候立即执行。先声明的1，所以calc("10",a,b) 将会先执行函数，进行fmt.Println() 输出。输出完后，会返回ret 给外围的calc 进行计算。
所以执行的顺序是10 x x x、20 x x x、2 x x x、1 x x x。


## for
### 例子1：

* **for range 语句相当于将range 结果赋值给for 后面的参数。如果使用指针赋值的话。结果会与预期不同。**


```
type student struct {
    Name string
    Age  int
}

func pase_student() {
    m := make(map[string]*student)
    stus := []student{
        {Name: "zhou", Age: 24},
        {Name: "li", Age: 23},
        {Name: "wang", Age: 22},
    }
    for _, stu := range stus {
        m[stu.Name] = &stu
    }
    for k,v:=range m{
        println(k,"=>",v.Name)
    }
}
OUTPUT >> 
wang,wang,wang
```
> **解决方法，可以用索引迭代，或者加入中间变量，使用中间变量来赋值。**


## select ##
- select 中只要有一个case能return，则立刻执行。
- 如果同一时间有多个case均能return则伪随机方式抽取任意一个执行。
- 如果没有一个case能return则可以执行”default”块。
- golang 的 select 就是监听 IO 操作，当 IO 操作发生时，触发相应的动作
- 每个case语句里必须是一个IO操作，确切的说，应该是一个面向channel的IO操作

## Go的并发机制

- Go 搭建了一个特有的两级线程模型，创造了独有的goroutine 这个专有名词。
- Go 推荐使用channel 来进行多个goroutine之间的数据传递，并保证整个过程的并发安全性。同时也提供了传统的同步方法，（比如互斥量，条件变量等）。
- Go 不以共享内存来进行通信，而是使用通信来进行共享内存。

### MPG
- **M** : machine    一个M代表一个内核线程，或称“工作线程”。
- **P** : processor  一个P代表执行一个Go代码片段所必须的资源（或称上下文环境）。
- **G** : goroutine  一个G代表一个Go代码片段。前者是对后者的一种封装。

Go 的runtime(运行时)会自动的维护这个MPG框架。 M与系统内核绑定。负责最终调用CPU 执行任务。同时与P（processor，上下文）对接，一个M可以对接一个P, 一个P 又可以对接多个G(Go的代码片段)，P中维护一个G的队列。其中M与P,P与G的关系是易变的，在实际调度中会发生改变。一个G 的执行需要P和M 共同支持、


## 关于锁（sync.Mutex）

{% highlight golang linenos%}
type UserAges struct {
	ages map[string]int
	sync.Mutex
}
func (ua *UserAges) Add(name string, age int) {
	ua.Lock()
	defer ua.Unlock()
	ua.ages[name] = age
}
func (ua *UserAges) Get(name string) int {
	if age, ok := ua.ages[name]; ok {
		return age
	}
	return -1
}
{% endhighlight %}

- 这段代码在执行Get时可能会出现panic报错

- 虽然有使用sync.Mutex做写锁，但是map是并发读写不安全的。map属于引用类型，并发读写时多个协程见是通过指针访问同一个地址，即访问共享变量，此时同时读写资源存在竞争关系。会报错误信息:“fatal error: concurrent map read and map write”。

1. sync.Mutex互斥锁。
2. sync.RWMutex读写锁，基于互斥锁的实现，可以加多个读锁或者一个写锁

{% highlight golang linenos%}
type UserAges struct {
	ages map[string]int
	sync.RWMutex
}

func (ua *UserAges) Add(name string, age int) {
	ua.Lock()
	defer ua.Unlock()
	ua.ages[name] = age
}

func (ua *UserAges) Get(name string) int {
	ua.RLock()
	defer ua.RUnlock()
	if age, ok := ua.ages[name]; ok {
		return age
	}

	return -1
}

func main() {
	count := 10000
	gw := sync.WaitGroup{}
	gw.Add(count * 3)
	u := UserAges{ages: map[string]int{}}
	add := func(i int) {
		u.Add(fmt.Sprintf("user_%d", i), i)
		gw.Done()
	}
	for i := 0; i < count; i++ {
		go add(i)
		go add(i)
	}
	for i := 0; i < count; i++ {
		go func(i int) {
			defer gw.Done()
			u.Get(fmt.Sprintf("user_%d", i))
			fmt.Print(".")
		}(i)
	}
	gw.Wait()
	fmt.Println("Done")
}

{% endhighlight %}

## channel

{% highlight golang linenos%}

func (set *threadSafeSet) Iter() <-chan interface{} {
	ch := make(chan interface{}) 
	go func() {
		set.RLock()
		for elem := range set.s {
			ch <- elem
		}
		close(ch)
		set.RUnlock()
	}()
	return ch
}
{% endhighlight %}

- 上面代码在make chan 的时候使用了默认的配置。默认channel是没有缓存的，这样会导致go func() 内部的for迭代写channel的操作一直阻塞。直到channel中的数据被读出。

- ch := make(chan interface{}) 和 ch := make(chan interface{},1)是不一样的
 - 无缓冲的 不仅仅是只能向 ch 通道放 一个值 而是一直要有人接收，那么ch <- elem才会继续下去，要不然就一直阻塞着，也就是说有接收者才去放，没有接收者就阻塞。
- 而缓冲为1则即使没有接收者也不会阻塞，因为缓冲大小是1只有当 放第二个值的时候 第一个还没被人拿走，这时候才会阻塞 

## struct

- go是强类型语言，所以不同类型的结构不能作比较，但是同一类型的实例值是可以比较的，实例不可以比较，因为是指针类型。
- 


### 指针和值类型

{% highlight golang linenos%}
package main

import (
	"fmt"
)

type People interface {
	Speak(string) string
}
type Student struct{}

func (stu *Student) Speak(think string) (talk string) {
	if think == "bitch" {
		talk = "You are a good boy"
	} else {
		talk = "hi"
	}
	return
}
func main() {
	// var peo People = Student{} // 错误
	var peo People = &Student{} 
    
	think := "bitch"
	fmt.Println(peo.Speak(think))
}
{% endhighlight %}

- 上面Student 的Speak方法，被声明成了只能被Student的指针调用。
- 可以声明成值调用。去掉* 。 调用的时候即使用了指针 goruntime 也能自动解指针。


<a href="javascript:scroll(0,0)">-- 返回顶部 --</a>