---
layout: article
title: go知识点
tags: 
- GO
- 学习记录
key: go-knowledge
aside:
  toc: true
---
## defer
- defer 是后进先出。panic 需要等defer 结束后才会向上传递。 出现panic会先按照defer的后入先出的顺序执行，最后才会执行panic。
### 例子1：

```
package main

import "fmt"

func calc(index string, a, b int) int {
	ret := a + b
	fmt.Println(index, a, b, ret)
	return ret
}

func main() {
	a := 1
	b := 2
	defer calc("1", a, calc("10", a, b))
	a = 0
	defer calc("2", a, calc("20", a, b))
	b = 1
}
OUTPUT >> 
10 1 2 3
20 0 2 2
2 0 2 2
1 1 3 4

```

- 解释：defer 依据先入后出的规则，外围的calc 将会是先2后1, 在calc内部的calc 会在声明defer的时候立即执行。先声明的1，所以calc("10",a,b) 将会先执行函数，进行fmt.Println() 输出。输出完后，会返回ret 给外围的calc 进行计算。
所以执行的顺序是10 x x x、20 x x x、2 x x x、1 x x x。


## for
### 例子1：

* **for range 语句相当于将range 结果赋值给for 后面的参数。如果使用指针赋值的话。结果会与预期不同。**


```
type student struct {
    Name string
    Age  int
}

func pase_student() {
    m := make(map[string]*student)
    stus := []student{
        {Name: "zhou", Age: 24},
        {Name: "li", Age: 23},
        {Name: "wang", Age: 22},
    }
    for _, stu := range stus {
        m[stu.Name] = &stu
    }
    for k,v:=range m{
        println(k,"=>",v.Name)
    }
}
OUTPUT >> 
wang,wang,wang
```
> **解决方法，可以用索引迭代，或者加入中间变量，使用中间变量来赋值。**


## select ##
- select 中只要有一个case能return，则立刻执行。
- 当如果同一时间有多个case均能return则伪随机方式抽取任意一个执行。
- 如果没有一个case能return则可以执行”default”块。