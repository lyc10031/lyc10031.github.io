---
layout: article
title: go知识点
tags: 
- GO
- 学习记录
key: go-tips
aside:
  toc: true
---
## golang 的堆和栈


```
var p *int    //全局指针变量
func f(){
    var i int
    i = 1
    p = &i    //全局指针变量指向局部变量i
}
```

```
func f(){
    p := new(int) //局部指针变量，使用new申请的空间
    *p = 1
}
```
###  上面程序中，第一个程序虽然i是通过var申请的局部变量，但是由于有外部指针指向访问，我们有路径可找到这个空间（变量能够逃逸出函数），所以局部变量i是申请在堆空间上。而第二个程序中p指针变量虽然是使用new申请的空间，但是由于退出函数就没有路径可寻找到它（变量无法逃出函数），所以局部变量p是申请在栈空间上的。


- golang 1.13 defer新增了一个heap字段用于标识_defer 是在堆上还是在栈上。编译器会根据应用场景去选择使用 deferproc 还是 deferprocStack 方法，他们分别是针对分配在堆上和栈上的使用场景。也就是当 defer func 是顶级函数时，将会分配到栈上。但是若在 defer func 外层出现显式的迭代循环，又或是出现隐式迭代，将会分配到堆上。

- 得益于其延迟对象的堆栈分配规则的改变，措施是由编译器通过对 defer 的 for-loop 迭代深度进行分析，如果 loopdepth 为 1，则设置逃逸分析的结果，将分配到栈上，否则分配到堆上。进而加快了defer的处理速度，官方说明 Go1.13 defer 性能提高 30%。

[Go1.13 defer 的性能是如何提高的？](https://book.eddycjy.com/golang/talk/go1.13-defer.html)


## defer
- defer 是后进先出。panic 需要等defer 结束后才会向上传递。 出现panic会先按照defer的后入先出的顺序执行，最后才会执行panic。
### 例子1：

```
package main

import "fmt"

func calc(index string, a, b int) int {
	ret := a + b
	fmt.Println(index, a, b, ret)
	return ret
}

func main() {
	a := 1
	b := 2
	defer calc("1", a, calc("10", a, b))
	a = 0
	defer calc("2", a, calc("20", a, b))
	b = 1
}
OUTPUT >> 
10 1 2 3
20 0 2 2
2 0 2 2
1 1 3 4

```

- 解释：defer 依据先入后出的规则，外围的calc 将会是先2后1, 在calc内部的calc 会在声明defer的时候立即执行。先声明的1，所以calc("10",a,b) 将会先执行函数，进行fmt.Println() 输出。输出完后，会返回ret 给外围的calc 进行计算。
所以执行的顺序是10 x x x、20 x x x、2 x x x、1 x x x。


## for
### 例子1：

* **for range 语句相当于将range 结果赋值给for 后面的参数。如果使用指针赋值的话。结果会与预期不同。**


```
type student struct {
    Name string
    Age  int
}

func pase_student() {
    m := make(map[string]*student)
    stus := []student{
        {Name: "zhou", Age: 24},
        {Name: "li", Age: 23},
        {Name: "wang", Age: 22},
    }
    for _, stu := range stus {
        m[stu.Name] = &stu
    }
    for k,v:=range m{
        println(k,"=>",v.Name)
    }
}
OUTPUT >> 
wang,wang,wang
```
> **解决方法，可以用索引迭代，或者加入中间变量，使用中间变量来赋值。**


## select ##
- select 中只要有一个case能return，则立刻执行。
- 如果同一时间有多个case均能return则伪随机方式抽取任意一个执行。
- 如果没有一个case能return则可以执行”default”块。

## Go的并发机制

- Go 搭建了一个特有的两级线程模型，创造了独有的goroutine 这个专有名词。
- Go 推荐使用channel 来进行多个goroutine之间的数据传递，并保证整个过程的并发安全性。同时也提供了传统的同步方法，（比如互斥量，条件变量等）。
- Go 不以共享内存来进行通信，而是使用通信来进行共享内存。

### MPG
- **M** : machine    一个M代表一个内核线程，或称“工作线程”。
- **P** : processor  一个P代表执行一个Go代码片段所必须的资源（或称上下文环境）。
- **G** : goroutine  一个G代表一个Go代码片段。前者是对后者的一种封装。

Go 的runtime(运行时)会自动的维护这个MPG框架。 M与系统内核绑定。负责最终调用CPU 执行任务。同时与P（processor，上下文）对接，一个M可以对接一个P, 一个P 又可以对接多个G(Go的代码片段)，P中维护一个G的队列。其中M与P,P与G的关系是易变的，在实际调度中会发生改变。一个G 的执行需要P和M 共同支持、


<a href="javascript:scroll(0,0)">-- 返回顶部 --</a>